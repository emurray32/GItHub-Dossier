{% extends "base.html" %}

{% block title %}Grow Pipeline - Lead Machine{% endblock %}

{% block breadcrumb %}
<nav class="breadcrumb-container" aria-label="Breadcrumb">
    <ol class="breadcrumb">
        <li class="breadcrumb-item">
            <a href="{{ url_for('accounts') }}">
                <svg class="breadcrumb-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                    <polyline points="9 22 9 12 15 12 15 22"></polyline>
                </svg>
                RepoRadar
            </a>
        </li>
        <li class="breadcrumb-separator">/</li>
        <li class="breadcrumb-item active" aria-current="page">Grow Pipeline</li>
    </ol>
</nav>
{% endblock %}

{% block head %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/grow.css') }}?v={{ cache_bust }}">
{% endblock %}


{% block content %}
<div class="page-header">
    <div class="container">
        <h1 class="page-title">Grow Pipeline</h1>
        <p class="page-subtitle">Rapidly fill the top of your funnel with new companies</p>
    </div>
</div>

<div class="container">
    <div class="grow-container">
        <!-- Top Panel: Bulk Import -->
        <div class="panel">
            <h2 class="panel-title">Bulk Import</h2>

            <!-- Tabs for different import methods -->
            <div class="bulk-import-tabs">
                <button class="bulk-import-tab active" onclick="switchImportTab('manual')">Manual Entry</button>
                <button class="bulk-import-tab" onclick="switchImportTab('csv')">Upload CSV</button>
                <button class="bulk-import-tab" onclick="switchImportTab('sheets')">Google Sheets</button>
            </div>

            <!-- Manual Entry Tab -->
            <div class="bulk-import-tab-content active" id="manualTab">
                <form class="import-form" id="importForm" onsubmit="processImport(event)">
                    <label class="import-label" for="companiesInput">Company Names (one per line)</label>
                    <textarea class="companies-textarea" id="companiesInput"
                        placeholder="Shopify&#10;Stripe&#10;Figma&#10;Slack&#10;Notion"></textarea>

                    <div class="import-options" style="display: flex; gap: 1rem; align-items: center; margin-bottom: 1rem;">
                        <label class="import-option" style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; color: var(--text-secondary); cursor: pointer;">
                            <input type="checkbox" id="skipDuplicates" style="accent-color: var(--accent-color);">
                            <span>Auto-skip duplicates</span>
                        </label>
                        <button type="button" class="check-duplicates-btn" onclick="checkForDuplicates()" style="padding: 0.5rem 1rem; font-size: 0.85rem; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-secondary); cursor: pointer;">
                            Check for Duplicates
                        </button>
                    </div>

                    <button type="submit" class="process-batch-btn" id="processBtn">
                        ‚ñ∂ Process Batch
                    </button>
                </form>
            </div>

            <!-- CSV Upload Tab -->
            <div class="bulk-import-tab-content" id="csvTab">
                <div class="file-upload-area" id="fileUploadArea" onclick="document.getElementById('csvFileInput').click()">
                    <span class="file-upload-label">üìÅ Choose CSV File or Drag Here</span>
                    <span class="file-upload-hint">CSV should have "Account Name", "Company Name", "Company", or "Account" column. Optional: "annual_revenue", "website"</span>
                    <button type="button" class="csv-upload-btn">Select File</button>
                </div>
                <input type="file" id="csvFileInput" accept=".csv" onchange="handleCSVFile(event)">
                <div id="fileSelectedInfo" style="display: none;" class="file-selected-info"></div>

                <!-- Column Mapping Preview -->
                <div id="columnMappingPreview" style="display: none; margin: 1rem 0; border: 1px solid var(--color-border); border-radius: 8px; overflow: hidden;">
                    <div style="padding: 0.75rem 1rem; background: var(--color-primary-subtle); border-bottom: 1px solid var(--color-border); display: flex; align-items: center; justify-content: space-between;">
                        <span style="font-weight: 600; font-size: 0.9rem; color: var(--color-text);">Column Mapping</span>
                        <span id="mappingStatus" style="font-size: 0.8rem; color: var(--color-text-secondary);"></span>
                    </div>
                    <div id="mappingRows" style="padding: 0.75rem 1rem; display: flex; flex-direction: column; gap: 0.5rem;"></div>
                    <div id="unmappedWarning" style="display: none; padding: 0.5rem 1rem 0.75rem; font-size: 0.8rem; color: var(--color-warning); background: rgba(245, 158, 11, 0.06);">
                        ‚ö† Some columns couldn't be mapped and will be stored as metadata
                    </div>
                </div>

                <button type="button" class="process-batch-btn" id="processCSVBtn" style="display: none;" onclick="processCSVImport()">
                    ‚ñ∂ Process CSV
                </button>
            </div>

            <!-- Google Sheets Tab -->
            <div class="bulk-import-tab-content" id="sheetsTab">
                <div id="sheetsStatus" style="margin-bottom: 1rem;">
                    <div style="text-align: center; padding: 1rem; color: var(--text-muted);">
                        Loading Google Sheets status...
                    </div>
                </div>
                <div id="sheetsConfigured" style="display: none;">
                    <div style="display: flex; gap: 0.75rem; margin-bottom: 1rem; align-items: center; flex-wrap: wrap;">
                        <label class="import-label" style="margin: 0;">Daily Limit:</label>
                        <input type="number" id="sheetsDailyLimit" value="300" min="1" max="1000"
                            style="width: 80px; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary);">
                        <label class="import-label" style="margin: 0;">Sheet Tab:</label>
                        <select id="sheetsTabSelect"
                            style="padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary);">
                            <option value="Sheet1">Sheet1</option>
                        </select>
                        <button type="button" class="process-batch-btn" style="margin: 0; padding: 0.6rem 1rem; font-size: 0.9rem;"
                            onclick="previewSheetSync()">
                            Preview
                        </button>
                    </div>
                    <div id="sheetsPreview" style="display: none; margin-bottom: 1rem;"></div>
                    <div style="display: flex; gap: 0.75rem; margin-bottom: 1rem;">
                        <button type="button" class="process-batch-btn" id="syncSheetsBtn" style="margin: 0; flex: 1;"
                            onclick="runSheetSync()">
                            Sync Now
                        </button>
                    </div>
                    <div style="padding: 0.75rem; background: var(--bg-secondary); border-radius: 6px; font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 1rem;">
                        <div id="sheetsLastSync">Last sync: Never</div>
                        <div id="sheetsCronStatus" style="margin-top: 0.25rem;">Daily cron: Checking...</div>
                    </div>
                </div>
                <div id="sheetsNotConfigured" style="display: none;">
                    <div style="padding: 2rem; text-align: center; color: var(--text-secondary);">
                        <p style="font-size: 1.1rem; margin-bottom: 1rem;">Google Sheets integration not configured</p>
                        <p style="font-size: 0.85rem; margin-bottom: 0.5rem;">Add these to your Replit Secrets:</p>
                        <pre style="text-align: left; background: var(--bg-secondary); padding: 1rem; border-radius: 8px; font-size: 0.8rem; overflow-x: auto; margin-bottom: 1rem;">GOOGLE_SHEETS_SPREADSHEET_ID=your_spreadsheet_id
GOOGLE_SHEETS_CREDENTIALS_JSON={"type":"service_account",...}</pre>
                    </div>
                </div>
            </div>

            <label class="import-label" for="consoleLog" style="margin-top: 1.5rem;">Activity Feed</label>
            <div class="console-log" id="consoleLog" role="log" aria-live="polite">
                <div class="console-empty">Activity will appear here when you start an import</div>
            </div>
        </div>

    </div>
</div>

{% endblock %}

{% block scripts %}
<!-- Papa Parse for robust CSV parsing -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script>
    let selectedCSVData = null;
    let csvFileInput = null;
    let currentColumnMappings = {}; // Stores current header‚Üífield mappings

    // --- Smart Column Mapping ---
    const FIELD_SYNONYMS = {
        'company_name': ['company_name', 'company name', 'company', 'account name', 'account_name',
                         'organization', 'org name', 'org_name', 'name', 'account', 'business name',
                         'business_name', 'firm', 'client name', 'client_name', 'prospect'],
        'website':      ['domain', 'website', 'company domain', 'company_domain', 'website url',
                         'website_url', 'url', 'web', 'company website', 'company_website',
                         'primary domain', 'site', 'homepage', 'web address'],
        'annual_revenue': ['annual_revenue', 'revenue', 'annual revenue', 'estimated_revenue',
                           'arr', 'yearly revenue', 'yearly_revenue', 'total revenue', 'company revenue',
                           'estimated revenue', 'rev'],
        'industry':     ['industry', 'sector', 'vertical', 'company industry', 'company_industry',
                         'account industry', 'market', 'segment', 'business type'],
        'employee_count': ['employees', 'employee count', 'employee_count', '# employees',
                           'num_employees', 'company size', 'number of employees', 'headcount',
                           'staff count', 'team size', 'size', 'num employees', 'employee_size'],
        'city':         ['city', 'hq city', 'headquarters city', 'company city', 'location city'],
        'state':        ['state', 'hq state', 'headquarters state', 'company state', 'region',
                         'province', 'location state'],
        'country':      ['country', 'hq country', 'headquarters country', 'company country',
                         'location country', 'nation'],
        'salesforce_id': ['salesforce_id', 'sf_id', 'account id', 'account_id', 'sfdc id',
                          'sfdc_id', 'crm_id', 'crm id', 'sf id', 'salesforce id']
    };

    const FIELD_LABELS = {
        'company_name': 'Company Name',
        'website': 'Website / Domain',
        'annual_revenue': 'Annual Revenue',
        'industry': 'Industry',
        'employee_count': 'Employee Count',
        'city': 'City',
        'state': 'State / Region',
        'country': 'Country',
        'salesforce_id': 'Salesforce ID'
    };

    function levenshtein(a, b) {
        const m = a.length, n = b.length;
        const dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));
        for (let i = 0; i <= m; i++) dp[i][0] = i;
        for (let j = 0; j <= n; j++) dp[0][j] = j;
        for (let i = 1; i <= m; i++)
            for (let j = 1; j <= n; j++)
                dp[i][j] = a[i-1] === b[j-1] ? dp[i-1][j-1] : 1 + Math.min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]);
        return dp[m][n];
    }

    function fuzzyMatchColumn(header) {
        const h = header.toLowerCase().trim();
        // Exact match first
        for (const [field, synonyms] of Object.entries(FIELD_SYNONYMS)) {
            if (synonyms.includes(h)) return { field, confidence: 'exact' };
        }
        // Contains match
        for (const [field, synonyms] of Object.entries(FIELD_SYNONYMS)) {
            for (const syn of synonyms) {
                if (h.includes(syn) || syn.includes(h)) return { field, confidence: 'partial' };
            }
        }
        // Fuzzy/Levenshtein match (threshold: 2 edits)
        let bestField = null, bestDist = Infinity;
        for (const [field, synonyms] of Object.entries(FIELD_SYNONYMS)) {
            for (const syn of synonyms) {
                const dist = levenshtein(h, syn);
                if (dist < bestDist && dist <= 2) { bestDist = dist; bestField = field; }
            }
        }
        if (bestField) return { field: bestField, confidence: 'fuzzy' };
        return { field: null, confidence: 'none' };
    }

    function autoMapColumns(headers) {
        const mappings = {};
        const usedFields = new Set();
        // First pass: exact matches
        for (const header of headers) {
            const match = fuzzyMatchColumn(header);
            if (match.confidence === 'exact' && !usedFields.has(match.field)) {
                mappings[header] = match.field;
                usedFields.add(match.field);
            }
        }
        // Second pass: partial + fuzzy for unmapped
        for (const header of headers) {
            if (mappings[header]) continue;
            const match = fuzzyMatchColumn(header);
            if (match.field && !usedFields.has(match.field)) {
                mappings[header] = match.field;
                usedFields.add(match.field);
            }
        }
        return mappings;
    }

    function renderMappingPreview(headers, mappings) {
        const container = document.getElementById('mappingRows');
        const preview = document.getElementById('columnMappingPreview');
        const statusEl = document.getElementById('mappingStatus');
        const unmappedEl = document.getElementById('unmappedWarning');
        container.innerHTML = '';

        const mappedCount = Object.values(mappings).filter(v => v).length;
        const hasCompanyName = Object.values(mappings).includes('company_name');
        statusEl.textContent = `${mappedCount} of ${headers.length} columns mapped`;

        let hasUnmapped = false;
        for (const header of headers) {
            const mapped = mappings[header] || '';
            if (!mapped) hasUnmapped = true;

            const row = document.createElement('div');
            row.style.cssText = 'display:flex;align-items:center;gap:0.5rem;padding:0.35rem 0;font-size:0.85rem;';

            const arrow = mapped ? '‚Üí' : '¬∑';
            const conf = fuzzyMatchColumn(header);
            const badge = conf.confidence === 'exact' ? '' :
                          conf.confidence === 'partial' ? '<span style="font-size:0.7rem;color:var(--color-info);margin-left:0.25rem;">~partial</span>' :
                          conf.confidence === 'fuzzy' ? '<span style="font-size:0.7rem;color:var(--color-warning);margin-left:0.25rem;">~fuzzy</span>' : '';

            row.innerHTML = `
                <span style="flex:1;font-family:var(--font-mono);color:var(--color-text-secondary);font-size:0.8rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${escapeHtml(header)}">${escapeHtml(header)}</span>
                <span style="color:var(--color-text-tertiary);">${arrow}</span>
                <select data-csv-header="${escapeHtml(header)}" onchange="updateColumnMapping(this)" style="flex:1;padding:0.35rem 0.5rem;border:1px solid var(--color-border);border-radius:6px;font-size:0.8rem;background:var(--color-bg);color:var(--color-text);">
                    <option value="">‚Äî skip (metadata) ‚Äî</option>
                    ${Object.entries(FIELD_LABELS).map(([k,v]) => `<option value="${k}" ${mapped===k ? 'selected' : ''}>${v}</option>`).join('')}
                </select>
                ${badge}
            `;
            container.appendChild(row);
        }

        unmappedEl.style.display = hasUnmapped ? 'block' : 'none';

        if (!hasCompanyName) {
            statusEl.innerHTML = '<span style="color:var(--color-destructive);">‚ö† No company name column detected ‚Äî please map one</span>';
        }

        preview.style.display = 'block';
        currentColumnMappings = {...mappings};
    }

    function updateColumnMapping(selectEl) {
        const header = selectEl.dataset.csvHeader;
        const newField = selectEl.value;

        // Remove old mapping for this header
        if (currentColumnMappings[header]) {
            delete currentColumnMappings[header];
        }

        // Check if field is already mapped by another header
        if (newField) {
            for (const [h, f] of Object.entries(currentColumnMappings)) {
                if (f === newField && h !== header) {
                    currentColumnMappings[h] = ''; // Clear duplicate
                    // Update the other select
                    const otherSelect = document.querySelector(`select[data-csv-header="${h}"]`);
                    if (otherSelect) otherSelect.value = '';
                }
            }
            currentColumnMappings[header] = newField;
        }

        // Update status
        const statusEl = document.getElementById('mappingStatus');
        const mappedCount = Object.values(currentColumnMappings).filter(v => v).length;
        const totalHeaders = document.querySelectorAll('#mappingRows select').length;
        const hasCompanyName = Object.values(currentColumnMappings).includes('company_name');
        statusEl.textContent = `${mappedCount} of ${totalHeaders} columns mapped`;
        if (!hasCompanyName) {
            statusEl.innerHTML = '<span style="color:var(--color-destructive);">‚ö† No company name column detected ‚Äî please map one</span>';
        }
    }

    // Restore CSV data from localStorage on page load (fixes data loss between page states)
    try {
        const savedCSVData = localStorage.getItem('pendingCSVImport');
        if (savedCSVData) {
            selectedCSVData = JSON.parse(savedCSVData);
            console.log('[CSV Import] Restored', selectedCSVData.length, 'companies from localStorage');
        }
    } catch (e) {
        console.error('[CSV Import] Error restoring from localStorage:', e);
    }

    function switchImportTab(tab) {
        // Update tab buttons
        document.querySelectorAll('.bulk-import-tab').forEach(btn => btn.classList.remove('active'));
        event.target.classList.add('active');

        // Update tab contents
        document.getElementById('manualTab').classList.remove('active');
        document.getElementById('csvTab').classList.remove('active');
        document.getElementById('sheetsTab').classList.remove('active');

        if (tab === 'manual') {
            document.getElementById('manualTab').classList.add('active');
        } else if (tab === 'csv') {
            document.getElementById('csvTab').classList.add('active');
            setupDragDrop();
        } else if (tab === 'sheets') {
            document.getElementById('sheetsTab').classList.add('active');
            loadSheetsStatus();
        }
    }

    function setupDragDrop() {
        const uploadArea = document.getElementById('fileUploadArea');
        if (!uploadArea) return;

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('drag-over');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) {
                document.getElementById('csvFileInput').files = e.dataTransfer.files;
                handleCSVFile({ target: { files: e.dataTransfer.files } });
            }
        });
    }

    // Store raw parsed CSV rows for re-mapping
    let rawCSVRows = null;
    let rawCSVHeaders = null;
    let currentCSVFileName = '';

    async function handleCSVFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (!file.name.endsWith('.csv')) {
            addConsoleEntry('Please select a CSV file', 'error');
            return;
        }
        currentCSVFileName = file.name;

        // Use Papa Parse to correctly handle multi-line quoted fields
        Papa.parse(file, {
            header: true,
            skipEmptyLines: true,
            transformHeader: (header) => header.trim().toLowerCase(),
            complete: async (results) => {
                try {
                    rawCSVRows = results.data;
                    rawCSVHeaders = results.meta.fields || [];

                    // Auto-map columns using fuzzy matching
                    const mappings = autoMapColumns(rawCSVHeaders);
                    currentColumnMappings = mappings;

                    // Show mapping preview
                    renderMappingPreview(rawCSVHeaders, mappings);

                    // Build companies from mappings
                    const companies = buildCompaniesFromMappings(rawCSVRows, rawCSVHeaders, mappings);

                    if (companies.length === 0) {
                        addConsoleEntry('No valid company names found in CSV. Check the column mapping above.', 'error');
                        return;
                    }

                    selectedCSVData = companies;
                    // Save to localStorage as backup
                    try {
                        localStorage.setItem('pendingCSVImport', JSON.stringify(companies));
                    } catch (e) {
                        console.error('[CSV Import] Error saving to localStorage:', e);
                    }
                    const infoDiv = document.getElementById('fileSelectedInfo');

                    // Check for duplicates
                    infoDiv.textContent = `Checking ${companies.length} companies for duplicates...`;
                    infoDiv.style.display = 'block';
                    infoDiv.style.background = 'rgba(14, 165, 233, 0.1)';
                    infoDiv.style.color = 'var(--accent-color)';

                    try {
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 60000);

                        const response = await fetch('/api/import/check-duplicates', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ companies: companies }),
                            signal: controller.signal
                        });

                        clearTimeout(timeoutId);
                        const data = await response.json();

                        if (response.ok) {
                            const newCount = data.new_companies || 0;
                            const duplicateCount = data.duplicates_found || 0;

                            if (duplicateCount > 0) {
                                infoDiv.textContent = `‚úì ${newCount} new accounts found (${duplicateCount} duplicates skipped) ‚Äî ${file.name}`;
                                addConsoleEntry(`Found ${newCount} new companies and ${duplicateCount} duplicates in CSV`, 'info');
                            } else {
                                infoDiv.textContent = `‚úì ${newCount} new accounts ready to import ‚Äî ${file.name}`;
                                addConsoleEntry(`All ${newCount} companies are new ‚Äî ready to process`, 'success');
                            }

                            infoDiv.style.background = 'rgba(34, 197, 94, 0.1)';
                            infoDiv.style.color = 'var(--success-color)';
                            document.getElementById('processCSVBtn').style.display = 'block';
                        } else {
                            infoDiv.textContent = `‚úì ${companies.length} companies loaded from ${file.name}`;
                            infoDiv.style.background = 'rgba(34, 197, 94, 0.1)';
                            infoDiv.style.color = 'var(--success-color)';
                            document.getElementById('processCSVBtn').style.display = 'block';
                            addConsoleEntry(`Ready to process ${companies.length} companies from CSV`, 'info');
                        }
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            infoDiv.textContent = `‚úì ${companies.length} companies loaded from ${file.name} (duplicate check timed out)`;
                            addConsoleEntry(`Duplicate check timed out ‚Äî duplicates will be skipped during import`, 'warning');
                        } else {
                            infoDiv.textContent = `‚úì ${companies.length} companies loaded from ${file.name}`;
                            addConsoleEntry(`Ready to process ${companies.length} companies from CSV`, 'info');
                        }
                        infoDiv.style.background = 'rgba(34, 197, 94, 0.1)';
                        infoDiv.style.color = 'var(--success-color)';
                        document.getElementById('processCSVBtn').style.display = 'block';
                    }
                } catch (error) {
                    addConsoleEntry(`Error processing CSV: ${error.message}`, 'error');
                }
            },
            error: (error) => {
                addConsoleEntry(`Error parsing CSV: ${error.message}`, 'error');
            }
        });
    }

    function buildCompaniesFromMappings(rows, headers, mappings) {
        // Build reverse map: field ‚Üí csv header
        const fieldToHeader = {};
        for (const [header, field] of Object.entries(mappings)) {
            if (field) fieldToHeader[field] = header;
        }

        const mappedHeaders = new Set(Object.keys(mappings).filter(h => mappings[h]));

        return rows.map(row => {
            const nameHeader = fieldToHeader['company_name'];
            if (!nameHeader) return null;
            const companyName = row[nameHeader];
            if (!companyName || !companyName.trim()) return null;

            const revenueHeader = fieldToHeader['annual_revenue'];
            const websiteHeader = fieldToHeader['website'];
            const industryHeader = fieldToHeader['industry'];
            const employeesHeader = fieldToHeader['employee_count'];
            const cityHeader = fieldToHeader['city'];
            const stateHeader = fieldToHeader['state'];
            const countryHeader = fieldToHeader['country'];
            const sfIdHeader = fieldToHeader['salesforce_id'];

            // Collect unmapped fields as metadata
            const metadata = {};
            for (const [key, value] of Object.entries(row)) {
                if (!mappedHeaders.has(key) && value && value.trim()) {
                    metadata[key] = value.trim();
                }
            }

            // Add mapped non-core fields to metadata too (so backend gets them)
            if (industryHeader && row[industryHeader]) metadata['industry'] = row[industryHeader].trim();
            if (employeesHeader && row[employeesHeader]) metadata['employee_count'] = row[employeesHeader].trim();
            if (cityHeader && row[cityHeader]) metadata['city'] = row[cityHeader].trim();
            if (stateHeader && row[stateHeader]) metadata['state'] = row[stateHeader].trim();
            if (countryHeader && row[countryHeader]) metadata['country'] = row[countryHeader].trim();
            if (sfIdHeader && row[sfIdHeader]) metadata['salesforce_id'] = row[sfIdHeader].trim();

            return {
                name: companyName.trim(),
                annual_revenue: validateRevenueValue(revenueHeader ? row[revenueHeader] : null),
                website: websiteHeader && row[websiteHeader] ? row[websiteHeader].trim() : null,
                metadata: Object.keys(metadata).length > 0 ? metadata : null
            };
        }).filter(company => company !== null);
    }

    // Validate that a value looks like a revenue number (e.g., "$50M", "4.6B", "50000000")
    // Returns the value if valid, null otherwise
    function validateRevenueValue(value) {
        if (!value || typeof value !== 'string') return null;
        const trimmed = value.trim();
        if (!trimmed) return null;

        // Pattern matches revenue formats like: $50M, $4.6B, 50000000, $50,000,000, 500K, ‚Ç¨50M
        // Must contain at least one digit to be considered a revenue value
        const revenuePattern = /^[$‚Ç¨¬£¬•]?\s*[\d,.]+\s*[KkMmBbTt]?$/;

        if (revenuePattern.test(trimmed)) {
            return trimmed;
        }

        return null;
    }

    // Strip surrounding quotes from a CSV field value
    function stripQuotes(value) {
        if (!value) return value;
        const trimmed = value.trim();
        // Remove surrounding double quotes (standard CSV format)
        if (trimmed.startsWith('"') && trimmed.endsWith('"')) {
            return trimmed.slice(1, -1);
        }
        // Also handle single leading quote (malformed data)
        if (trimmed.startsWith('"')) {
            return trimmed.slice(1);
        }
        return trimmed;
    }

    function parseCSV(csv) {
        const lines = csv.trim().split('\n');
        if (lines.length === 0) return [];

        const header = lines[0].split(',').map(h => stripQuotes(h).toLowerCase());
        const originalHeader = lines[0].split(',').map(h => stripQuotes(h)); // Preserve original case for metadata keys
        const companyNameIndex = header.findIndex(h =>
            h === 'account name' || h === 'company name' || h === 'company' || h === 'account' || h === 'company_name' || h === 'name'
        );

        if (companyNameIndex === -1) {
            throw new Error('CSV must have "Account Name", "Company Name", "Company", or "Account" column');
        }

        // Find annual_revenue column (optional)
        const revenueIndex = header.findIndex(h =>
            h === 'annual_revenue' || h === 'revenue' || h === 'annual revenue' || h === 'estimated_revenue'
        );

        // Find website column (optional)
        const websiteIndex = header.findIndex(h =>
            h === 'website' || h === 'url' || h === 'company_website' || h === 'company website' || h === 'site'
        );

        // Identify which column indices are "known" (displayed) fields
        const knownIndices = new Set([companyNameIndex]);
        if (revenueIndex !== -1) knownIndices.add(revenueIndex);
        if (websiteIndex !== -1) knownIndices.add(websiteIndex);

        const companies = [];
        for (let i = 1; i < lines.length; i++) {
            const fields = lines[i].split(',').map(f => stripQuotes(f));
            if (fields[companyNameIndex]) {
                // Validate revenue value - ignore text that doesn't look like a number
                const rawRevenue = revenueIndex !== -1 ? fields[revenueIndex] : null;
                const rawWebsite = websiteIndex !== -1 ? fields[websiteIndex] : null;

                // Collect all extra fields into metadata object
                const metadata = {};
                for (let j = 0; j < fields.length; j++) {
                    if (!knownIndices.has(j) && fields[j] && fields[j].trim()) {
                        // Use original header name as key (preserves case)
                        const key = originalHeader[j] || `column_${j}`;
                        metadata[key] = fields[j].trim();
                    }
                }

                const company = {
                    name: fields[companyNameIndex],
                    annual_revenue: validateRevenueValue(rawRevenue),
                    website: rawWebsite || null,
                    metadata: Object.keys(metadata).length > 0 ? metadata : null
                };
                companies.push(company);
            }
        }

        return companies;
    }

    async function processCSVImport() {
        console.log('[CSV Import] processCSVImport called, selectedCSVData:', selectedCSVData ? selectedCSVData.length : 'null');
        
        // Try to restore from localStorage if selectedCSVData is null
        if (!selectedCSVData || selectedCSVData.length === 0) {
            try {
                const savedData = localStorage.getItem('pendingCSVImport');
                if (savedData) {
                    selectedCSVData = JSON.parse(savedData);
                    console.log('[CSV Import] Restored from localStorage:', selectedCSVData.length, 'companies');
                }
            } catch (e) {
                console.error('[CSV Import] Error restoring from localStorage:', e);
            }
        }
        
        if (!selectedCSVData || selectedCSVData.length === 0) {
            addConsoleEntry('No CSV data loaded - please re-upload the file', 'error');
            console.error('[CSV Import] No CSV data available after localStorage check');
            return;
        }

        const btn = document.getElementById('processCSVBtn');
        btn.disabled = true;

        clearConsole();
        addConsoleEntry(`Starting batch import of ${selectedCSVData.length} companies from CSV (auto-skipping duplicates)...`, 'info');
        console.log('[CSV Import] Sending', selectedCSVData.length, 'companies to /api/import');

        try {
            const response = await fetch('/api/import', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ companies: selectedCSVData, skip_duplicates: true })
            });

            const data = await response.json();

            if (response.ok) {
                // Handle async batch import response
                if (data.status === 'queued' && data.batch_id) {
                    addConsoleEntry(`Import batch #${data.batch_id} queued (${data.total_count} companies)`, 'info');
                    addConsoleEntry('Processing in background...', 'info');

                    // Reset CSV immediately and clear localStorage
                    selectedCSVData = null;
                    localStorage.removeItem('pendingCSVImport');
                    console.log('[CSV Import] Cleared localStorage after successful import');
                    document.getElementById('csvFileInput').value = '';
                    document.getElementById('fileSelectedInfo').style.display = 'none';
                    document.getElementById('processCSVBtn').style.display = 'none';

                    // Batch is now queued - redirect immediately (processing continues in background)
                    addConsoleEntry('', 'info');
                    addConsoleEntry('Import queued successfully - processing in background', 'success');
                    addConsoleEntry(`${data.total_count} accounts will be processed automatically`, 'info');
                    addConsoleEntry('You can navigate away - no need to wait on this page', 'info');
                    addConsoleEntry('', 'info');
                    addConsoleEntry('Redirecting to Accounts page...', 'info');
                    setTimeout(() => {
                        window.location.href = `/accounts?highlight_batch=${data.batch_id}`;
                    }, 1500);
                } else if (data.results) {
                    // Legacy synchronous response format (if ever used)
                    handleLegacyImportResponse(data);
                } else {
                    addConsoleEntry('Import started successfully', 'success');
                    if (data.batch_id) {
                        addConsoleEntry('Redirecting to Accounts page...', 'info');
                        setTimeout(() => {
                            window.location.href = `/accounts?highlight_batch=${data.batch_id}`;
                        }, 1500);
                    }
                }
            } else {
                addConsoleEntry(`Error: ${data.error}`, 'error');
            }
        } catch (error) {
            addConsoleEntry(`Network Error: ${error.message}`, 'error');
        } finally {
            btn.disabled = false;
        }
    }

    async function pollBatchProgress(batchId, totalCount) {
        let lastProcessed = 0;
        const pollInterval = 2000; // 2 seconds
        const maxPolls = 600; // Max 20 minutes of polling
        let pollCount = 0;

        const poll = async () => {
            try {
                const response = await fetch(`/api/import-batch/${batchId}`);
                const data = await response.json();

                if (!response.ok) {
                    addConsoleEntry(`Error checking batch status: ${data.error}`, 'error');
                    return;
                }

                const processed = data.processed_count || 0;
                const total = data.total_count || totalCount;
                const status = data.status;

                // Update progress if changed
                if (processed > lastProcessed) {
                    const progressBar = '‚ñà'.repeat(Math.floor(processed / total * 20)) + '‚ñë'.repeat(20 - Math.floor(processed / total * 20));
                    addConsoleEntry(`[${progressBar}] ${processed}/${total} (${data.progress_percent}%)`, 'info');
                    lastProcessed = processed;
                }

                if (status === 'completed') {
                    addConsoleEntry('', 'info');
                    addConsoleEntry(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'info');
                    addConsoleEntry(`Import Complete`, 'success');
                    addConsoleEntry(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'info');
                    addConsoleEntry(`Processed: ${processed} / ${total}`, 'success');
                    addConsoleEntry('', 'info');
                    addConsoleEntry('Redirecting to results...', 'info');
                    setTimeout(() => {
                        window.location.href = `/accounts?highlight_batch=${batchId}`;
                    }, 2000);
                    return;
                } else if (status === 'failed') {
                    addConsoleEntry('Import batch failed', 'error');
                    return;
                } else if (pollCount < maxPolls) {
                    pollCount++;
                    setTimeout(poll, pollInterval);
                } else {
                    addConsoleEntry('Import is still processing. Check accounts page for results.', 'info');
                    setTimeout(() => {
                        window.location.href = `/accounts?highlight_batch=${batchId}`;
                    }, 2000);
                }
            } catch (error) {
                addConsoleEntry(`Error polling batch status: ${error.message}`, 'error');
            }
        };

        // Start polling
        setTimeout(poll, pollInterval);
    }

    function handleLegacyImportResponse(data) {
        // Handle legacy synchronous response format
        addConsoleEntry('', 'info');
        addConsoleEntry(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'info');
        addConsoleEntry(`Import Complete`, 'success');
        addConsoleEntry(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'info');

        const results = data.results || [];
        const added = data.added || [];
        const failed = data.failed || [];
        const totalProcessed = data.total_processed || results.length;

        const enrichedCount = results.filter(r => r.status === 'enriched').length;
        addConsoleEntry(`Added: ${added.length} / ${totalProcessed}`, 'success');
        if (enrichedCount > 0) {
            addConsoleEntry(`Enriched: ${enrichedCount} / ${totalProcessed}`, 'success');
        }
        addConsoleEntry(`Failed: ${failed.length} / ${totalProcessed}`, 'error');
        addConsoleEntry('', 'info');

        // Show results
        results.forEach(result => {
            if (result.status === 'added') {
                addConsoleEntry(`Added ${result.company} ‚Üí ${result.github_org}`, 'success');
            } else if (result.status === 'enriched') {
                addConsoleEntry(`Enriched ${result.company} with revenue data`, 'success');
            } else {
                addConsoleEntry(`${result.company} (${result.status})`, 'error');
            }
        });

        // Reset CSV and clear localStorage
        selectedCSVData = null;
        localStorage.removeItem('pendingCSVImport');
        console.log('[CSV Import] Cleared localStorage after legacy import');
        document.getElementById('csvFileInput').value = '';
        document.getElementById('fileSelectedInfo').style.display = 'none';
        document.getElementById('processCSVBtn').style.display = 'none';

        // Redirect to accounts page with batch_id
        if (data.batch_id) {
            addConsoleEntry('', 'info');
            addConsoleEntry('Redirecting to results...', 'info');
            setTimeout(() => {
                window.location.href = `/accounts?highlight_batch=${data.batch_id}`;
            }, 2000);
        }
    }

    async function checkForDuplicates() {
        const input = document.getElementById('companiesInput').value.trim();

        if (!input) {
            addConsoleEntry('Please enter at least one company name to check', 'warning');
            return;
        }

        const companies = input.split('\n').map(c => c.trim()).filter(c => c.length > 0);

        clearConsole();
        addConsoleEntry(`Checking ${companies.length} companies for duplicates...`, 'info');

        try {
            const response = await fetch('/api/import/check-duplicates', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ companies })
            });

            const data = await response.json();

            if (response.ok) {
                addConsoleEntry('', 'info');
                addConsoleEntry(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'info');
                addConsoleEntry(`Duplicate Check Results`, 'info');
                addConsoleEntry(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'info');
                addConsoleEntry(`Total checked: ${data.total_checked}`, 'info');
                addConsoleEntry(`New companies: ${data.new_companies}`, 'success');
                addConsoleEntry(`Duplicates found: ${data.duplicates_found}`, data.duplicates_found > 0 ? 'warning' : 'success');
                addConsoleEntry('', 'info');

                data.results.forEach(result => {
                    if (result.is_duplicate) {
                        const match = result.matches[0];
                        const reason = match.match_reason.replace('_', ' ');
                        const confidence = match.match_confidence;
                        addConsoleEntry(`‚ö† ${result.company} ‚Üí matches "${match.company_name}" (${reason}, ${confidence}% confidence)`, 'warning');
                    } else {
                        addConsoleEntry(`‚úì ${result.company} ‚Üí new company`, 'success');
                    }
                });

                if (data.duplicates_found > 0) {
                    addConsoleEntry('', 'info');
                    addConsoleEntry('Tip: Enable "Auto-skip duplicates" to import only new companies', 'info');
                }
            } else {
                addConsoleEntry(`Error: ${data.error}`, 'error');
            }
        } catch (error) {
            addConsoleEntry(`Network Error: ${error.message}`, 'error');
        }
    }

    async function processImport(event) {
        event.preventDefault();

        const input = document.getElementById('companiesInput').value.trim();
        const btn = document.getElementById('processBtn');
        const skipDuplicates = document.getElementById('skipDuplicates')?.checked || false;

        if (!input) {
            addConsoleEntry('Please enter at least one company name', 'warning');
            return;
        }

        const companies = input.split('\n').map(c => c.trim()).filter(c => c.length > 0);

        clearConsole();
        btn.disabled = true;

        if (skipDuplicates) {
            addConsoleEntry(`Starting batch import of ${companies.length} companies (auto-skipping duplicates)...`, 'info');
        } else {
            addConsoleEntry(`Starting batch import of ${companies.length} companies...`, 'info');
        }

        try {
            const response = await fetch('/api/import', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ companies, skip_duplicates: skipDuplicates })
            });

            const data = await response.json();

            if (response.ok) {
                addConsoleEntry('', 'info');
                addConsoleEntry(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'info');
                addConsoleEntry(`Import Complete`, 'success');
                addConsoleEntry(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'info');

                // Handle new batch-style response
                if (data.status === 'queued' && data.batch_id) {
                    addConsoleEntry(`Queued ${data.total_count} companies for import`, 'success');

                    // Show skipped duplicates if any
                    if (data.skipped_duplicates && data.skipped_duplicates.length > 0) {
                        addConsoleEntry(`Skipped ${data.skipped_count} duplicates:`, 'warning');
                        data.skipped_duplicates.forEach(skip => {
                            addConsoleEntry(`  ‚ö† ${skip.company} ‚Üí matches "${skip.existing_match}" (${skip.match_reason.replace('_', ' ')})`, 'warning');
                        });
                    }

                    // Poll for progress
                    await pollBatchProgress(data.batch_id, data.total_count);
                } else if (data.status === 'skipped') {
                    addConsoleEntry('All companies were duplicates - nothing to import', 'warning');
                    if (data.skipped_duplicates && data.skipped_duplicates.length > 0) {
                        data.skipped_duplicates.forEach(skip => {
                            addConsoleEntry(`  ‚ö† ${skip.company} ‚Üí matches "${skip.existing_match}"`, 'warning');
                        });
                    }
                } else if (data.added || data.results) {
                    // Handle legacy response format
                    addConsoleEntry(`Added: ${data.added?.length || 0} / ${data.total_processed || 0}`, 'success');
                    addConsoleEntry(`Failed: ${data.failed?.length || 0} / ${data.total_processed || 0}`, 'error');
                    addConsoleEntry('', 'info');

                    // Show results
                    (data.results || []).forEach(result => {
                        if (result.status === 'added') {
                            addConsoleEntry(`Added ${result.company} ‚Üí ${result.github_org}`, 'success');
                        } else {
                            addConsoleEntry(`${result.company} (${result.status})`, 'error');
                        }
                    });

                    // Redirect to accounts page with batch_id to highlight new imports
                    if (data.batch_id) {
                        addConsoleEntry('', 'info');
                        addConsoleEntry('Redirecting to results...', 'info');
                        setTimeout(() => {
                            window.location.href = `/accounts?highlight_batch=${data.batch_id}`;
                        }, 2000);
                    }
                }
            } else {
                addConsoleEntry(`Error: ${data.error}`, 'error');
            }
        } catch (error) {
            addConsoleEntry(`Network Error: ${error.message}`, 'error');
        } finally {
            btn.disabled = false;
        }
    }

    function clearConsole() {
        const log = document.getElementById('consoleLog');
        log.innerHTML = '';
    }

    function addConsoleEntry(message, type = 'info') {
        const log = document.getElementById('consoleLog');

        // Clear "empty" message on first entry
        if (log.querySelector('.console-empty')) {
            log.innerHTML = '';
        }

        const entry = document.createElement('div');
        entry.className = `console-entry ${type}`;
        entry.textContent = message;
        log.appendChild(entry);

        // Auto-scroll to bottom
        log.scrollTop = log.scrollHeight;
    }

    function escapeHtml(text) {
        if (!text) return '';
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return String(text).replace(/[&<>"']/g, m => map[m]);
    }

    // Initialize on page load
    // =================================================================
    // GOOGLE SHEETS INTEGRATION
    // =================================================================

    async function loadSheetsStatus() {
        try {
            const response = await fetch('/api/sheets/status');
            const data = await response.json();

            if (data.configured) {
                document.getElementById('sheetsConfigured').style.display = 'block';
                document.getElementById('sheetsNotConfigured').style.display = 'none';
                document.getElementById('sheetsStatus').style.display = 'none';

                if (data.tabs && data.tabs.length > 0) {
                    const select = document.getElementById('sheetsTabSelect');
                    select.innerHTML = data.tabs.map(tab =>
                        `<option value="${escapeHtml(tab.name)}">${escapeHtml(tab.name)}</option>`
                    ).join('');
                }

                if (data.title) {
                    addConsoleEntry(`Connected to: "${data.title}"`, 'info');
                }

                const configResp = await fetch('/api/sheets/config');
                const config = await configResp.json();
                if (config.daily_limit) document.getElementById('sheetsDailyLimit').value = config.daily_limit;
                if (config.sheet_name) document.getElementById('sheetsTabSelect').value = config.sheet_name;
                if (config.last_sync_at) document.getElementById('sheetsLastSync').textContent = `Last sync: ${config.last_sync_at}`;
                const cronEnabled = config.enabled ? 'Enabled' : 'Disabled';
                const cronTime = `${String(config.cron_hour || 6).padStart(2, '0')}:${String(config.cron_minute || 0).padStart(2, '0')}`;
                document.getElementById('sheetsCronStatus').textContent = `Daily cron: ${cronEnabled} (${cronTime})`;
            } else {
                document.getElementById('sheetsConfigured').style.display = 'none';
                document.getElementById('sheetsNotConfigured').style.display = 'block';
                document.getElementById('sheetsStatus').style.display = 'none';
                if (data.errors) data.errors.forEach(err => addConsoleEntry(`Sheets: ${err}`, 'warning'));
            }
        } catch (error) {
            document.getElementById('sheetsStatus').innerHTML =
                `<div style="padding: 1rem; color: var(--error-color);">Error loading Sheets status: ${escapeHtml(error.message)}</div>`;
        }
    }

    async function previewSheetSync() {
        const limit = document.getElementById('sheetsDailyLimit').value;
        const sheetName = document.getElementById('sheetsTabSelect').value;
        clearConsole();
        addConsoleEntry(`Previewing ${limit} accounts from "${sheetName}"...`, 'info');
        try {
            const response = await fetch('/api/sheets/sync', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ limit: parseInt(limit), sheet_name: sheetName, dry_run: true })
            });
            const data = await response.json();
            if (data.status === 'success' || data.preview) {
                addConsoleEntry(`Total rows in sheet: ${data.total_rows_in_sheet}`, 'info');
                addConsoleEntry(`Unprocessed rows: ${data.unprocessed_rows}`, 'info');
                addConsoleEntry(`Accounts to import: ${data.accounts_read}`, 'info');
                if (data.headers_found) addConsoleEntry(`Mapped columns: ${data.headers_found.join(', ')}`, 'info');
                if (data.preview && data.preview.length > 0) {
                    addConsoleEntry(``, 'info');
                    addConsoleEntry(`Preview (first 10):`, 'info');
                    data.preview.slice(0, 10).forEach((a, i) => {
                        const domain = a.domain ? ` (${a.domain})` : '';
                        addConsoleEntry(`  ${i + 1}. ${a.company_name}${domain}`, 'success');
                    });
                    if (data.preview.length > 10) addConsoleEntry(`  ... and ${data.preview.length - 10} more`, 'info');
                }
            } else {
                addConsoleEntry(`Error: ${data.error || 'Unknown error'}`, 'error');
            }
        } catch (error) {
            addConsoleEntry(`Network Error: ${error.message}`, 'error');
        }
    }

    async function runSheetSync() {
        const btn = document.getElementById('syncSheetsBtn');
        const limit = document.getElementById('sheetsDailyLimit').value;
        const sheetName = document.getElementById('sheetsTabSelect').value;
        btn.disabled = true;
        btn.textContent = 'Syncing...';
        clearConsole();
        addConsoleEntry(`Starting Google Sheets sync (limit: ${limit})...`, 'info');
        try {
            const response = await fetch('/api/sheets/sync', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ limit: parseInt(limit), sheet_name: sheetName })
            });
            const data = await response.json();
            addConsoleEntry('', 'info');
            addConsoleEntry('Sync Complete', 'success');
            addConsoleEntry(`Added: ${(data.added || []).length}`, 'success');
            addConsoleEntry(`Skipped (existing): ${(data.skipped_existing || []).length}`, 'warning');
            addConsoleEntry(`Failed (no GitHub): ${(data.failed_resolve || []).length}`, 'error');
            if (data.scan_queued > 0) addConsoleEntry(`Queued for scanning: ${data.scan_queued}`, 'info');
            if (data.added && data.added.length > 0) {
                addConsoleEntry('', 'info');
                data.added.forEach(a => addConsoleEntry(`  Added: ${a.company} -> ${a.github_org}`, 'success'));
            }
            if (data.errors && data.errors.length > 0) data.errors.forEach(e => addConsoleEntry(`Warning: ${e}`, 'warning'));
            document.getElementById('sheetsLastSync').textContent = `Last sync: ${data.timestamp || 'Just now'}`;
            if (data.added && data.added.length > 0) {
                addConsoleEntry('', 'info');
                addConsoleEntry('Redirecting to accounts...', 'info');
                setTimeout(() => { window.location.href = '/accounts'; }, 3000);
            }
        } catch (error) {
            addConsoleEntry(`Network Error: ${error.message}`, 'error');
        } finally {
            btn.disabled = false;
            btn.textContent = 'Sync Now';
        }
    }

    document.addEventListener('DOMContentLoaded', function () {
        const textarea = document.querySelector('.companies-textarea');
        if (textarea) {
            const resizeTextarea = () => {
                textarea.style.height = 'auto';
                textarea.style.height = `${textarea.scrollHeight}px`;
            };

            textarea.addEventListener('input', resizeTextarea);
            resizeTextarea();
        }
        
        // Restore UI state if there's pending CSV data
        if (selectedCSVData && selectedCSVData.length > 0) {
            console.log('[CSV Import] Restoring UI for', selectedCSVData.length, 'pending companies');
            const infoDiv = document.getElementById('fileSelectedInfo');
            if (infoDiv) {
                infoDiv.textContent = `${selectedCSVData.length} companies ready to import (restored from previous session)`;
                infoDiv.style.display = 'block';
                infoDiv.style.background = 'rgba(34, 197, 94, 0.1)';
                infoDiv.style.color = 'var(--success-color)';
            }
            const processBtn = document.getElementById('processCSVBtn');
            if (processBtn) {
                processBtn.style.display = 'block';
            }
            // Switch to CSV tab
            const csvTab = document.getElementById('csvTab');
            const manualTab = document.getElementById('manualTab');
            if (csvTab && manualTab) {
                manualTab.classList.remove('active');
                csvTab.classList.add('active');
            }
            addConsoleEntry(`Restored ${selectedCSVData.length} companies from previous session - click "Process CSV" to import`, 'info');
        }
    });
</script>
{% endblock %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Lead Machine{% endblock %}</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='45' fill='%231a237e'/><circle cx='50' cy='50' r='30' fill='none' stroke='white' stroke-width='4'/><line x1='71' y1='71' x2='90' y2='90' stroke='white' stroke-width='8' stroke-linecap='round'/></svg>">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    {% block head %}{% endblock %}
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    <nav class="navbar" role="navigation" aria-label="Main navigation">
        <div class="nav-container">
            <a href="{{ url_for('accounts') }}" class="nav-brand">
                <svg class="brand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                    <circle cx="11" cy="11" r="7"></circle>
                    <line x1="16.65" y1="16.65" x2="21" y2="21"></line>
                </svg>
                Lead Machine
            </a>
            <div class="nav-links">
                <a href="{{ url_for('accounts') }}" class="{% if request.endpoint == 'accounts' %}active{% endif %}">Accounts</a>
                <a href="{{ url_for('grow') }}" class="{% if request.endpoint == 'grow' %}active{% endif %}">Grow</a>
                <a href="{{ url_for('history') }}" class="{% if request.endpoint == 'history' %}active{% endif %}">History</a>
            </div>
        </div>
    </nav>

    <main class="main-content" id="main-content">
        {% block content %}{% endblock %}
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>Lead Machine - Deep-Dive Research Engine</p>
        </div>
    </footer>

    <!-- Rules Panel - Floating Button and Slide-out Panel -->
    <button id="rules-panel-toggle" class="rules-panel-toggle" title="View Scanning Rules">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
            <polyline points="14 2 14 8 20 8"></polyline>
            <line x1="16" y1="13" x2="8" y2="13"></line>
            <line x1="16" y1="17" x2="8" y2="17"></line>
            <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        <span class="rules-btn-label">Rules</span>
    </button>

    <div id="rules-panel" class="rules-panel">
        <div class="rules-panel-header">
            <h2>Scanning Rules</h2>
            <div class="rules-panel-actions">
                <a href="/api/rules/download" class="rules-download-btn" title="Download rules for LLM">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    <span>Download</span>
                </a>
                <span id="rules-last-updated" class="rules-timestamp">Loading...</span>
                <button id="rules-refresh-btn" class="rules-refresh-btn" title="Mark rules as reviewed">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="23 4 23 10 17 10"></polyline>
                        <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                    </svg>
                </button>
            </div>
            <button id="rules-panel-close" class="rules-panel-close" title="Close">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="rules-panel-content" id="rules-panel-content">
            <div class="rules-loading">Loading rules...</div>
        </div>
    </div>
    <div id="rules-panel-overlay" class="rules-panel-overlay"></div>

    <script>
        function timeAgo(dateString) {
            const date = new Date(dateString);
            if (Number.isNaN(date.getTime())) {
                return dateString;
            }

            const seconds = Math.floor((Date.now() - date.getTime()) / 1000);
            if (seconds < 60) return `${Math.max(seconds, 1)} sec${seconds === 1 ? '' : 's'} ago`;

            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes} min${minutes === 1 ? '' : 's'} ago`;

            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours} hour${hours === 1 ? '' : 's'} ago`;

            const days = Math.floor(hours / 24);
            if (days < 30) return `${days} day${days === 1 ? '' : 's'} ago`;

            const months = Math.floor(days / 30);
            if (months < 12) return `${months} month${months === 1 ? '' : 's'} ago`;

            const years = Math.floor(months / 12);
            return `${years} year${years === 1 ? '' : 's'} ago`;
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.scanned-time').forEach((element) => {
                const dateString = element.dataset.iso || element.textContent.trim();
                element.textContent = timeAgo(dateString);
            });
        });

        document.addEventListener('keydown', (event) => {
            if (event.key !== '/' || event.defaultPrevented) return;

            const target = event.target;
            const isEditable = target instanceof HTMLElement
                && (target.isContentEditable
                    || ['INPUT', 'TEXTAREA', 'SELECT'].includes(target.tagName));

            if (isEditable) return;

            const searchInput = document.querySelector("input[name='q']");
            if (searchInput) {
                event.preventDefault();
                searchInput.focus();
            }
        });

        // Rules Panel functionality
        const rulesPanel = document.getElementById('rules-panel');
        const rulesPanelToggle = document.getElementById('rules-panel-toggle');
        const rulesPanelClose = document.getElementById('rules-panel-close');
        const rulesPanelOverlay = document.getElementById('rules-panel-overlay');
        const rulesPanelContent = document.getElementById('rules-panel-content');
        const rulesLastUpdated = document.getElementById('rules-last-updated');
        const rulesRefreshBtn = document.getElementById('rules-refresh-btn');

        let rulesLoaded = false;
        let explanationsCache = {};

        // Map category names to rule keys for AI explanations
        const categoryToRuleKey = {
            'Signal 1: RFC & Discussion Keywords': 'rfc_keywords',
            'Signal 2: Smoking Gun Libraries': 'smoking_gun_libs',
            'Signal 2b: Smoking Gun Fork Repos': 'smoking_gun_fork_repos',
            'Signal 2c: Linter Libraries': 'linter_libraries',
            'Signal 2d: CMS i18n Libraries': 'cms_i18n_libs',
            'Signal 3: Ghost Branch Patterns': 'ghost_branch_patterns',
            'Signal 4: Documentation Intent Keywords': 'documentation_intent_keywords',
            'Documentation Context Keywords': 'documentation_context_keywords',
            'Exclusion Folders (Disqualifiers)': 'exclusion_folders',
            'Source Locale Patterns (Goldilocks Exception)': 'source_locale_patterns',
            'Dependency Files Scanned': 'dependency_injection_files',
            'Framework Config Files': 'framework_config_files',
            'Documentation Files Scanned': 'documentation_files',
            'i18n Script Keywords': 'i18n_script_keywords',
            'Build Script i18n Keywords': 'build_script_i18n_keywords',
            'Open Protocol Disqualifiers': 'open_protocol_disqualifiers',
            'High-Value Repo Patterns': 'high_value_patterns',
            'Low-Value Repo Patterns': 'low_value_patterns',
            'High-Value Languages': 'high_value_languages',
            'Launched Indicators (Negative)': 'documentation_launched_indicators'
        };

        function formatRulesTimestamp(isoString) {
            const date = new Date(isoString);
            return date.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true,
                timeZoneName: 'short'
            });
        }

        function getPhaseColor(phase) {
            const colors = {
                'THINKING': '#3b82f6',
                'PREPARING': '#16a34a',
                'ACTIVE': '#8b5cf6',
                'LAUNCHED': '#dc2626',
                'DISQUALIFIED': '#6b7280',
                'SCORING': '#d97706'
            };
            return colors[phase] || '#64748b';
        }

        function getPhaseLabel(phase) {
            const labels = {
                'THINKING': 'Thinking Phase',
                'PREPARING': 'Preparing Phase',
                'ACTIVE': 'Active Phase',
                'LAUNCHED': 'Already Launched',
                'DISQUALIFIED': 'Disqualifier',
                'SCORING': 'Scoring'
            };
            return labels[phase] || phase;
        }

        async function loadExplanation(ruleKey, explanationEl, btn) {
            // Check cache first
            if (explanationsCache[ruleKey]) {
                explanationEl.textContent = explanationsCache[ruleKey];
                explanationEl.classList.remove('loading');
                return;
            }

            explanationEl.innerHTML = '<span class="explanation-loading">Loading explanation...</span>';
            explanationEl.classList.add('loading');
            btn.disabled = true;

            try {
                const response = await fetch('/api/rules/explain', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ rules: [ruleKey] })
                });
                const data = await response.json();

                if (data.explanations && data.explanations[ruleKey]) {
                    explanationsCache[ruleKey] = data.explanations[ruleKey];
                    explanationEl.textContent = data.explanations[ruleKey];
                } else {
                    explanationEl.textContent = 'Unable to load explanation.';
                }
            } catch (error) {
                console.error('Failed to load explanation:', error);
                explanationEl.textContent = 'Failed to load explanation. Please try again.';
            } finally {
                explanationEl.classList.remove('loading');
                btn.disabled = false;
            }
        }

        function toggleExplanation(btn) {
            const section = btn.closest('.rules-section');
            const dropdown = section.querySelector('.rules-explanation-dropdown');
            const explanationEl = dropdown.querySelector('.rules-explanation-text');
            const ruleKey = btn.dataset.ruleKey;
            const isOpen = dropdown.classList.contains('open');

            if (isOpen) {
                dropdown.classList.remove('open');
                btn.classList.remove('open');
            } else {
                dropdown.classList.add('open');
                btn.classList.add('open');
                // Load explanation if not already loaded
                if (!explanationEl.textContent || explanationEl.classList.contains('loading')) {
                    loadExplanation(ruleKey, explanationEl, btn);
                }
            }
        }

        async function loadRules() {
            try {
                const response = await fetch('/api/rules');
                const data = await response.json();

                rulesLastUpdated.textContent = 'Updated: ' + formatRulesTimestamp(data.last_updated);

                let html = '';

                // Scoring summary section
                html += '<div class="rules-section rules-scoring-section">';
                html += '<h3 class="rules-section-title">Intent Score Weights</h3>';
                html += '<div class="rules-scoring-grid">';
                for (const [key, value] of Object.entries(data.scoring.weights)) {
                    const label = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    html += `<div class="rules-score-item"><span class="rules-score-label">${label}</span><span class="rules-score-value">${value} pts</span></div>`;
                }
                html += '</div>';
                html += '<h4 class="rules-subsection-title">Goldilocks Scores</h4>';
                html += '<div class="rules-scoring-grid">';
                for (const [key, value] of Object.entries(data.scoring.goldilocks_scores)) {
                    const label = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    html += `<div class="rules-score-item"><span class="rules-score-label">${label}</span><span class="rules-score-value">${value}</span></div>`;
                }
                html += '</div>';
                html += '</div>';

                // Scan configuration
                html += '<div class="rules-section rules-config-section">';
                html += '<h3 class="rules-section-title">Scan Configuration</h3>';
                html += '<div class="rules-config-grid">';
                html += `<div class="rules-config-item"><span class="rules-config-label">Max Repos to Scan</span><span class="rules-config-value">${data.scan_config.max_repos_to_scan}</span></div>`;
                html += `<div class="rules-config-item"><span class="rules-config-label">Repo Inactivity Days</span><span class="rules-config-value">${data.scan_config.repo_inactivity_days}</span></div>`;
                html += `<div class="rules-config-item"><span class="rules-config-label">RFC Lookback Days</span><span class="rules-config-value">${data.scan_config.rfc_lookback_days}</span></div>`;
                html += `<div class="rules-config-item"><span class="rules-config-label">Doc Proximity Chars</span><span class="rules-config-value">${data.scan_config.documentation_proximity_chars}</span></div>`;
                html += '</div>';
                html += '</div>';

                // Categories with dropdown explanations
                for (const category of data.categories) {
                    const phaseColor = getPhaseColor(category.phase);
                    const phaseLabel = getPhaseLabel(category.phase);
                    const ruleKey = categoryToRuleKey[category.name] || '';

                    html += '<div class="rules-section">';
                    html += `<div class="rules-category-header">`;
                    html += `<h3 class="rules-section-title">${category.name}</h3>`;
                    html += `<span class="rules-phase-badge" style="background-color: ${phaseColor}20; color: ${phaseColor}; border: 1px solid ${phaseColor}40;">${phaseLabel}</span>`;
                    html += '</div>';
                    html += `<p class="rules-description">${category.description}</p>`;

                    // Add "What does this mean?" dropdown
                    if (ruleKey) {
                        html += `<button class="rules-explain-btn" data-rule-key="${ruleKey}" onclick="toggleExplanation(this)">`;
                        html += `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="explain-icon"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>`;
                        html += `<span>What does this mean?</span>`;
                        html += `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="chevron-icon"><polyline points="6 9 12 15 18 9"></polyline></svg>`;
                        html += `</button>`;
                        html += `<div class="rules-explanation-dropdown">`;
                        html += `<div class="rules-explanation-text"></div>`;
                        html += `</div>`;
                    }

                    if (category.lookback_days) {
                        html += `<p class="rules-lookback">Lookback: ${category.lookback_days} days</p>`;
                    }
                    html += '<div class="rules-items">';
                    for (const item of category.items) {
                        html += `<span class="rules-item">${item}</span>`;
                    }
                    html += '</div>';
                    html += '</div>';
                }

                // Lead status labels
                html += '<div class="rules-section rules-status-section">';
                html += '<h3 class="rules-section-title">Lead Status Labels</h3>';
                html += '<div class="rules-status-grid">';
                for (const [key, value] of Object.entries(data.scoring.lead_status_labels)) {
                    html += `<div class="rules-status-item"><span class="rules-status-key">${key.toUpperCase()}</span><span class="rules-status-value">${value}</span></div>`;
                }
                html += '</div>';
                html += '</div>';

                rulesPanelContent.innerHTML = html;
                rulesLoaded = true;
            } catch (error) {
                console.error('Failed to load rules:', error);
                rulesPanelContent.innerHTML = '<div class="rules-error">Failed to load rules. Please try again.</div>';
            }
        }

        async function refreshRulesTimestamp() {
            try {
                rulesRefreshBtn.disabled = true;
                rulesRefreshBtn.classList.add('refreshing');
                const response = await fetch('/api/rules/refresh', { method: 'POST' });
                const data = await response.json();
                if (data.success) {
                    rulesLastUpdated.textContent = 'Updated: ' + formatRulesTimestamp(data.last_updated);
                }
            } catch (error) {
                console.error('Failed to refresh rules timestamp:', error);
            } finally {
                rulesRefreshBtn.disabled = false;
                rulesRefreshBtn.classList.remove('refreshing');
            }
        }

        function openRulesPanel() {
            rulesPanel.classList.add('open');
            rulesPanelOverlay.classList.add('visible');
            document.body.style.overflow = 'hidden';
            if (!rulesLoaded) {
                loadRules();
            }
        }

        function closeRulesPanel() {
            rulesPanel.classList.remove('open');
            rulesPanelOverlay.classList.remove('visible');
            document.body.style.overflow = '';
        }

        rulesPanelToggle.addEventListener('click', openRulesPanel);
        rulesPanelClose.addEventListener('click', closeRulesPanel);
        rulesPanelOverlay.addEventListener('click', closeRulesPanel);
        rulesRefreshBtn.addEventListener('click', refreshRulesTimestamp);

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && rulesPanel.classList.contains('open')) {
                closeRulesPanel();
            }
        });
    </script>

    {% block scripts %}{% endblock %}
</body>
</html>
